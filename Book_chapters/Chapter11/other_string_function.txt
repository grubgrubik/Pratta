Other String Functions

library <string.h>

The ANSI C library has more than 20 string-handling functions, and the following list summarizes some of the more commonly used ones:

■ char *strcpy(char * restrict s1, const char * restrict s2);
This function copies the string (including the null character) pointed to by s2 to the
location pointed to by s1. The return value is s1.
■ char *strncpy(char * restrict s1, const char * restrict s2, size_t n);
This function copies to the location pointed to by s1 no more than n characters from the
string pointed to by s2. The return value is s1. No characters after a null character are
copied and, if the source string is shorter than n characters, the target string is padded
with null characters. If the source string has n or more characters, no null character is
copied. The return value is s1.
■ char *strcat(char * restrict s1, const char * restrict s2);
The string pointed to by s2 is copied to the end of the string pointed to by s1. The first
character of the s2 string is copied over the null character of the s1 string. The return
value is s1.
■ char *strncat(char * restrict s1, const char * restrict s2, size_t n);
No more than the first n characters of the s2 string are appended to the s1 string, with
the first character of the s2 string being copied over the null character of the s1 string.
The null character and any characters following it in the s2 string are not copied, and a
null character is appended to the result. The return value is s1.
■ int strcmp(const char * s1, const char * s2);
This function returns a positive value if the s1 string follows the s2 string in the
machine collating sequence, the value 0 if the two strings are identical, and a negative
value if the first string precedes the second string in the machine collating sequence.
■ int strncmp(const char * s1, const char * s2, size_t n);
This function works like strcmp(), except that the comparison stops after n characters or
when the first null character is encountered, whichever comes first.
■ char *strchr(const char * s, int c);
This function returns a pointer to the first location in the string s that holds the
character c. (The terminating null character is part of the string, so it can be searched
for.) The function returns the null pointer if the character is not found.
■ char *strpbrk(const char * s1, const char * s2);
This function returns a pointer to the first location in the string s1 that holds any
character found in the s2 string. The function returns the null pointer if no character is
found.
■ char *strrchr(const char * s, int c);
This function returns a pointer to the last occurrence of the character c in the string
s. (The terminating null character is part of the string, so it can be searched for.) The
function returns the null pointer if the character is not found.
■ char *strstr(const char * s1, const char * s2);
This function returns a pointer to the first occurrence of string s2 in string s1. The
function returns the null pointer if the string is not found.
■ size_t strlen(const char * s);
This function returns the number of characters, not including the terminating null
character, found in the string s

Note that these prototypes use the keyword const to indicate which strings are not altered by a
function. For example, consider the following:
char *strcpy(char * restrict s1, const char * restrict s2);
It means s2 points to a string that can’t be changed, at least not by the strcpy() function,
but s1 points to a string that can be changed. This makes sense, because s1 is the target string,
which gets altered, and s2 is the source string, which should be left unchanged.
The keyword restrict, discussed in Chapter 12, indicates restrictions on how the function
arguments should be used, for example, not copying a string into itself.
The size_t type, as discussed in Chapter 5, “Operators, Expressions, and Statements,” is whatever type the sizeof operator returns. 
C states that the sizeof operator returns an integer
type, but it doesn’t specify which integer type, so size_t can be unsigned int on one system
and unsigned long on another. The string.h file defines size_t for a particular system or
else refers to another header file having the definition.
As mentioned earlier, Reference Section V lists all the functions in the string.h family. Many
implementations provide additional functions beyond those required by the ANSI standard.
You should check the documentation for your implementation to see what is available.

Let’s look at a simple use of one of these functions. Earlier we saw that fgets(), when it
reads a line of input, stores the newline in the destination string. Our s_gets() function used
a while loop to detect that newline character, but we can use strchr() instead. First, use
strchr() to find the newline, if any. If the function finds the newline, it returns the address of
the newline, and you then can place a null character at that address:
char line[80];
char * find;
fgets(line, 80, stdin);
find = strchr(line, '\n'); // look for newline
if (find) // if the address is not NULL,
*find = '\0'; // place a null character there
If strchr() fails to find a newline, fgets() ran into the size limit before reaching the end of
the line. You can add an else, as we did in s_gets(), to the if to process that circumstance.
























